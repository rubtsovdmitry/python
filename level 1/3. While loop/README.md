# 1.3.1.task.py
# Условие:
# Пользователь вводит целое число n (от 1 до 9), программа выводит лесенку из n ступенек, i-я ступень состоит из цифр от 1 до i без пробелов. Например, для n = 4 нужно вывести:
# 1
# 12
# 123
# 1234

##########################

# 1.3.2.task.py
# Условие:
# Количество и сумма цифр в числе.
# Пользователь вводит большое целое число (например, 4568). Программа выводит на экран все цифры этого числа по одной (в любом порядке), считает количество цифр в этом числе, считает сумму цифр в этом числе (например, 4+5+6+8 для числа 4568).

##########################

# 1.3.3.task.py
# Условие:
# Подписка.
# Пользователь хочет подписаться на некий сервис. Подписка будет стоить 1000₽ в месяц. Пользователь вводит сумму на своём счету (один раз). Дальше начинается цикл, в котором программа спрашивает “Хотите ли продолжить подписку (да/нет)?” Пусть 1 итерация цикла означает 1 месяц. Если пользователь печатает “нет”, цикл прекращается, программа показывает сколько осталось на счету денег. Если печатает “да”, то подписка продолжается, со счёта списывается 1000р., и цикл продолжается. При этом, если денег на счету недостаточно, то подписка тоже прекратится. Баланс на счету пользователя ни в коем случае не должен оказаться меньше нуля.

##########################

# 1.3.4.task.py
# Условие:
# Проверка номера кредитки.
# Последняя цифра номера банковской карты (и некоторых других номеров карт и счетов) - это всегда контрольная сумма, которая считается по алгоритму Луна. Таким образом, если пользователь ошибётся в одной цифре или перепутает две цифры местами, то это легко вычислить на стороне терминала, не делая запрос в банк. 
# Пользователь вводит номер кредитной карты (16-значное целое число), а программа вычисляет и проверяет контрольную сумму, и говорит, валидный номер или нет.
# Алгоритм подсчёта суммы:
# - цифры проверяемой последовательности нумеруются справа налево (Последняя цифра тоже считается, её номер - единица).
# - цифры, оказавшиеся на нечётных местах, остаются без изменений.
# - цифры, стоящие на чётных местах, умножаются на 2.
# - если в результате такого умножения возникает число больше 9, оно заменяется суммой цифр получившегося произведения — однозначным числом, то есть цифрой.
# - все полученные в результате преобразования цифры складываются. Если сумма кратна 10, то исходные данные верны.
# Примеры корректных номеров:
# 5019 5555 4444 5555
# 8171 9999 0000 0000 021
# 4917 4845 8989 7107
# 6011 5564 4857 8945 8
# 5425 2334 3010 9903

##########################

# 1.3.5.task.py
# Камень, ножницы, бумага.
# Условие:
# Программа реализует известную игру: "Камень, ножницы, бумага". После окончания, выводит результат на экран.

##########################

# 1.3.6.task.py
# Среднее значение.
# Условие:
# В данном упражнении вы должны написать программу для подсчета среднего значения всех введенных пользователем чисел. Индикатором окончания ввода будет служить ноль. При этом программа должна выдавать соответствующее сообщение об ошибке, если первым же введенным пользователем значением будет ноль.

##########################

# 1.3.7.task.py
# Никаких центов.
# Условие:
# 4 февраля 2013 года Королевским канадским монетным двором была выпущена последняя монета номиналом в один цент. После вывода центов из обращения все магазины вынуждены были изменить цены на товары таким образом, чтобы они стали кратны пяти центам (расчеты по банковским картам по-прежнему ведутся с учетом центов). И хотя продавцы вольны сами определять политику преобразования цен, большинство из них просто округлили цены до ближайших пяти центов. Напишите программу, запрашивающую у пользователя цены, пока не будет введена пустая строка. На первой строке выведите сумму всех введенных пользователем сумм, а на второй – сумму, которую покупатель должен заплатить наличными. Эта сумма должна быть округлена до ближайших пяти центов (т.е. округлённые суммы всех покупок в итоге будут составлять сумму кратную пяти центам без округления).

##########################

# 1.3.8.task.py
# Найти периметр многоугольника.
# Условие:
# Напишите программу для расчета периметра заданного многоугольника. 
# Начните с запроса у пользователя координат x и y первой точки многоугольника. Продолжайте запрашивать координаты следующих точек фигуры, пока пользователь не оставит строку ввода координаты по оси x или y пустой.
# После ввода каждой пары значений вы должны вычислить длину очередной стороны многоугольника и прибавить полученное значение к будущему ответу. По окончании ввода необходимо вычислить расстояние от последней введенной точки до первой, чтобы замкнуть фигуру, и вывести итоговый результат.

##########################

# 1.3.9.task.py
# Средняя оценка.
# Условие:
# В разных странах успеваемость студентов в университетах ведется по-разному: где-то в качестве оценок используются буквы, где-то цифры. Соответствие между ними приведено ниже:
# A: 4.0
# A-: 3.7
# B+: 3.3
# B: 3.0
# B-: 2.7
# C+: 2.3
# C: 2.0
# C-: 1.7
# D+: 1.3
# D: 1.0
# F: 0
# Сейчас вам нужно будет рассчитать среднюю оценку по произвольному количеству введенных пользователем буквенных оценок. 
# Для окончания ввода можно использовать индикатор в виде пустой строки. Например, если пользователь последовательно введет оценки A, затем C+, а после этого B и пустую строку, средний результат должен составить 3,1. Никаких проверок на ошибки проводить не нужно.

##########################

# 1.3.10.task.py
# Билеты в зоопарк.
# Условие:
# В зоопарке цена входного билета зависит от возраста посетителя. Дети до двух лет допускаются бесплатно. Дети в возрасте от трех до 12 лет могут посещать зоопарк за $14,00. Пенсионерам старше 65 лет вход обойдется в $18,00, а обычный взрослый билет стоит $23,00.
# Напишите программу, которая будет запрашивать возраст всех посетителей в группе (по одному за раз) и выводить общую цену билетов для посещения зоопарка этой группой. В качестве индикатора окончания ввода можно использовать пустую строку. Общую цену билетов стоит выводить в формате с двумя знаками после запятой.

##########################

# 1.3.11.task.py
# Гипотеза Коллатца.
# Условие:
# Представьте себе последовательность целых чисел, организованную следующим образом:
# - начинаться последовательность должна с любого положительного числа;
# - пока последний элемент последовательности не равен единице, выполнять:
#       *** если последний элемент последовательности четный, тогда добавить новый элемент к последовательности путем деления последнего элемента на два с округлением вниз;
#       *** иначе добавить новый элемент к последовательности путем умножения последнего элемента на три с добавлением единицы.
# Гипотеза Коллатца утверждает, что подобная последовательность при условии того, что начинается с положительного числа, рано или поздно завершится единицей. И хотя это так и не было доказано, все указывает на то, что это так и есть.
# Напишите программу, которая будет запрашивать у пользователя целое число и выводить все числа, начиная с введенного числа и заканчивая единицей.

##########################

# 1.3.12.task.py
# Наибольший общий делитель.
# Условие:
# Наибольший общий делитель двух положительных чисел представляет собой наибольшее число, на которое без остатка делятся оба числа.
# Напишите программу, запрашивающую у пользователя два положительных целых числа и выводящую для них наибольший общий делитель.

##########################

# 1.3.13.task.py
# Простые множители.
# Условие:
# Напишите программу, которая будет запрашивать целое число у пользователя. Если пользователь введет значение, меньшее двух, необходимо вывести соответствующее сообщение об ошибке. Иначе нужно перечислить в столбец список простых множителей заданного числа, которые при перемножении дали бы исходное число.

##########################

# 1.3.14.task.py
# Максимальное число в последовательности.
# Условие:
# Это упражнение преследует цель идентификации количества смен максимального значения в коллекции случайных чисел. Ряд должен быть заполнен числами от 1 до 100. При этом последовательность может содержать дубликаты, а некоторых чисел из диапазона от 1 до 100 в ней может не быть. Сделайте паузу и подумайте с листочком в руках, как вы решили бы эту задачу. Многие стали бы сравнивать каждое очередное выпавшее число с текущим максимумом в последовательности и при необходимости обновлять максимум. Это вполне подходящий способ, который приведет к правильному результату при соблюдении алгоритма. А как вы думаете, сколько раз обновится максимум на протяжении генерирования всей последовательности?
# На этот вопрос можно ответить при помощи теории вероятностей, но мы попробуем провести необходимые симуляции. Для начала в вашей программе должно выбираться случайное число из диапазона от 1 до 100. Сразу сохраните это значение как максимальное. Далее сгенерируйте еще 99 случайных чисел в том же диапазоне. Для каждого значения выполняйте ту же проверку и при необходимости обновляйте максимум, попутно увеличивая переменную, хранящую количество «смен лидера», на единицу. Выводите каждое сгенерированное число на новой строке, добавляя примечание в случае, если на этом шаге обновлялся максимум и сколько раз обновлялся максимум.
