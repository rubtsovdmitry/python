# 4.1.task.py
# Бинарный поиск.
# Рассмотрим пример того, как работает бинарный поиск. 
# Сыграем в простую игру: я загадал число от 1 до 100. Вы должны отгадать моё число, использовав как можно меньше попыток. При каждой попытке я буду давать один из трёх ответов: "мало", "много" или "угадал". 
# Существует эффективный поиск. Начинать поиск нужно с половины, тем самым сразу исключая половину чисел из поиска.

##########################################################

# 4.2.task.py
# Сортировка выбором.
# Допустим, у Вас на компьютере записана музыка и для каждого исполнителя хранится счётчик воспроизведений. Вы хотите отсортировать список по убыванию счётчика воспроизведений, чтобы самые любимые исполнители стояли на первых местах. 
# Одно из возможных решений - пройти по списку и найти исполнителя с наибольшим количеством воспроизведений. Этот исполнитель добавляется в новый список. Потом то же самое происходит со следующим по количеству воспроизведений исполнителем.
# Продолжая действовать так, мы получаем отсортированный список.
# В итоге, чтобы найти исполнителя с наибольшим значением счётчика воспроизведения, необходимо проверить каждый элемент в списке. Это делается за время O(n). При каждом выполнении операций количество элементов, которые нужно проверить, сокращается. Со временем всё сведётся к проверке всего одного элемента. И общее время выполнения сводится к O(n**2).
# Алгоритм сортировки выбором лёгок для понимания, но медленно работает.

##########################################################

# 4.3.task.py
# Задача о коммивояжере.
# Это задача с очень плохим временем выполнения равным O(n!). При добавлении ещё одного элемента время выполнения растёт с ужасающей скоростью. 
# У нас есть задача побывать в пяти городах, при этом побывать в каждом городе только один раз. Кроме первого, из которого мы начинаем наш путь, и в который мы должны вернуться последним действием.
# Программа должна спросить название городов и их координаты (широту и долготу) и вывести маршрут с кротчайшим расстоянием для объезда всех городов.
# Для подсчёта расстояния между городами по их координатам можно использовать задачу 1.1.15.task.py.

##########################################################

# 4.4.task.py
# Рекурсия. Факториал.
# Найти факториал числа, используя рекурсию.

##########################################################

# 4.5.task.py
# Рекурсия. Слова палиндромы.
# Дано множество слов: data = {"казак", "шалаш", "потоп", "закат", "солнце", "река", "мадам"}  
# Программа должна определить какие слова являются палиндромами, используя рекурсию.

##########################################################

# 4.6.task.py
# Рекурсия. Поиск символа в тексте.
# Дана строка: 
# data = "Рекурсивные алгоритмы применимы в большом количестве задач, определения которых могут быть выражены через самих себя. \
#         И список подобных задач не ограничивается работой с целыми числами. \
#         Представьте, что вам необходимо выяснить, сколько раз определенный символ встречается в строке. \
#         Для решения этой задачи может быть написана рекурсивная функция, принимающая на вход строку и искомый символ и возвращающая количество появлений этого символа в строке."  
# Программа должна найти сколько раз попадается буква "а" в тексте, используя рекурсию.

##########################################################

# 4.7.task.py
# Рекурсия. Фибоначчи.
# Программа должна спросить сколько чисел Фибоначчи вывести на экран. Вывести список с числами Фибоначчи.
# Числа Фибоначчи должны быть найдены с помощью рекурсии.

##########################################################

# 4.8.task.py
# Рекурсия. Сумма чисел.
# Программа должна рекурсивно вызывать функцию, которая будет спрашивать число у пользователя. Каждый раз функция просит ввод числа, для отмены нужно просто ввести -enter-. В итоге должна быть выведена сумма всех введённых чисел.

##########################################################

# 4.9.task.py
# Рекурсия. Наибольший общий делитель.
# Напишите программу, реализующую алгоритм Евклида для определения наибольшего общего делителя двух положительных чисел, введенных пользователем. Проверьте программу на работоспособность с очень большими числами. Результат должен высчитываться очень быстро даже для огромных входных значений, состоящих из сотен чисел. Причина заключается в очень высокой эффективности данного алгоритма.
# Этот алгоритм описывается так:
# Если b = 0, тогда возвращаем a - базовый случай
# Иначе передаём в рекурсию (b,  a % b).

##########################################################

# 4.10.task.py
# Рекурсия. Возведение числа в степень.
# Программа должна запросить у пользователя число (n) и степень (x), в которую будем возводить это число.
# Программа должна вывести результаты возведения числа в степень от 0 до введённой степени пользователем (n ** 0, n ** 1, ... n ** x).

##########################################################

# 4.11.task.py
# Рекурсия. Сумма степеней числа.
# Программа должна запросить у пользователя число (n) и степень (x), до которой будем возводить это число.
# Нужно вывести сумму всех степеней числа от 0 до x.

##########################################################

# 4.12.task.py
# Рекурсия. Сумма чисел в списке.
# Необходимо посчитать сумму всех чисел в списке.
# data = [0, 1, 2, 3, 2, 1, 0, 6]

##########################################################

# 4.13.task.py
# Рекурсия. Перевод числа из десятичной системы счисления в двоичную.
# Программа должна переводить десятичную систему счисления в двоичную с помощью рекурсии.
