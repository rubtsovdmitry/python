# 4.1.task.py
# Бинарный поиск.
# Рассмотрим пример того, как работает бинарный поиск. 
# Сыграем в простую игру: я загадал число от 1 до 100. Вы должны отгадать моё число, использовав как можно меньше попыток. При каждой попытке я буду давать один из трёх ответов: "мало", "много" или "угадал". 
# Существует эффективный поиск. Начинать поиск нужно с половины, тем самым сразу исключая половину чисел из поиска.

##########################################################

# 4.2.task.py
# Сортировка выбором.
# Допустим, у Вас на компьютере записана музыка и для каждого исполнителя хранится счётчик воспроизведений. Вы хотите отсортировать список по убыванию счётчика воспроизведений, чтобы самые любимые исполнители стояли на первых местах. 
# Одно из возможных решений - пройти по списку и найти исполнителя с наибольшим количеством воспроизведений. Этот исполнитель добавляется в новый список. Потом то же самое происходит со следующим по количеству воспроизведений исполнителем.
# Продолжая действовать так, мы получаем отсортированный список.
# В итоге, чтобы найти исполнителя с наибольшим значением счётчика воспроизведения, необходимо проверить каждый элемент в списке. Это делается за время O(n). При каждом выполнении операций количество элементов, которые нужно проверить, сокращается. Со временем всё сведётся к проверке всего одного элемента. И общее время выполнения сводится к O(n**2).
# Алгоритм сортировки выбором лёгок для понимания, но медленно работает.

##########################################################

# 4.3.task.py
# Задача о коммивояжере.
# Это задача с очень плохим временем выполнения равным O(n!). При добавлении ещё одного элемента время выполнения растёт с ужасающей скоростью. 
# У нас есть задача побывать в пяти городах, при этом побывать в каждом городе только один раз. Кроме первого, из которого мы начинаем наш путь, и в который мы должны вернуться последним действием.
# Программа должна спросить название городов и их координаты (широту и долготу) и вывести маршрут с кротчайшим расстоянием для объезда всех городов.
# Для подсчёта расстояния между городами по их координатам можно использовать задачу 1.1.15.task.py.

##########################################################

# 4.4.task.py
# Рекурсия. Факториал.
# Найти факториал числа, используя рекурсию.

##########################################################

# 4.5.task.py
# Рекурсия. Слова палиндромы.
# Дано множество слов: data = {"казак", "шалаш", "потоп", "закат", "солнце", "река", "мадам"}  
# Программа должна определить какие слова являются палиндромами, используя рекурсию.

##########################################################

# 4.6.task.py
# Рекурсия. Поиск символа в тексте.
# Дана строка: 
# data = "Рекурсивные алгоритмы применимы в большом количестве задач, определения которых могут быть выражены через самих себя. \
#         И список подобных задач не ограничивается работой с целыми числами. \
#         Представьте, что вам необходимо выяснить, сколько раз определенный символ встречается в строке. \
#         Для решения этой задачи может быть написана рекурсивная функция, принимающая на вход строку и искомый символ и возвращающая количество появлений этого символа в строке."  
# Программа должна найти сколько раз попадается буква "а" в тексте, используя рекурсию.

##########################################################

# 4.7.task.py
# Рекурсия. Фибоначчи.
# Программа должна спросить сколько чисел Фибоначчи вывести на экран. Вывести список с числами Фибоначчи.
# Числа Фибоначчи должны быть найдены с помощью рекурсии.

##########################################################

# 4.8.task.py
# Рекурсия. Сумма чисел.
# Программа должна рекурсивно вызывать функцию, которая будет спрашивать число у пользователя. Каждый раз функция просит ввод числа, для отмены нужно просто ввести -enter-. В итоге должна быть выведена сумма всех введённых чисел.

##########################################################

# 4.9.task.py
# Рекурсия. Наибольший общий делитель.
# Напишите программу, реализующую алгоритм Евклида для определения наибольшего общего делителя двух положительных чисел, введенных пользователем. Проверьте программу на работоспособность с очень большими числами. Результат должен высчитываться очень быстро даже для огромных входных значений, состоящих из сотен чисел. Причина заключается в очень высокой эффективности данного алгоритма.
# Этот алгоритм описывается так:
# Если b = 0, тогда возвращаем a - базовый случай
# Иначе передаём в рекурсию (b,  a % b).

##########################################################

# 4.10.task.py
# Рекурсия. Возведение числа в степень.
# Программа должна запросить у пользователя число (n) и степень (x), в которую будем возводить это число.
# Программа должна вывести результаты возведения числа в степень от 0 до введённой степени пользователем (n ** 0, n ** 1, ... n ** x).

##########################################################

# 4.11.task.py
# Рекурсия. Сумма степеней числа.
# Программа должна запросить у пользователя число (n) и степень (x), до которой будем возводить это число.
# Нужно вывести сумму всех степеней числа от 0 до x.

##########################################################

# 4.12.task.py
# Рекурсия. Сумма чисел в списке.
# Необходимо посчитать сумму всех чисел в списке.
# data = [0, 1, 2, 3, 2, 1, 0, 6]

##########################################################

# 4.13.task.py
# Рекурсия. Перевод числа из десятичной системы счисления в двоичную.
# Программа должна переводить десятичную систему счисления в двоичную с помощью рекурсии.

##########################################################

# 4.14.task.py
# Рекурсия. Фонетический алфавит НАТО.
# Фонетический алфавит представляет собой таблицу обозначений букв, каждой из которых соответствует то или иное слово. Широкое распространение такие алфавиты приобретают в условиях повышенной зашумленности каналов передачи информации, когда собеседник может просто не расслышать конкретную букву. В таких случаях вместо букв используются целые слова. Один из наиболее распространенных фонетических алфавитов был разработан в военном блоке НАТО. Соответствие букв и слов в нем приведено в словаре:
#     NATO = {
#        "A": "Alpha",
#        "B": "Bravo",
#        "C": "Charlie",
#        "D": "Delta",
#        "E": "Echo",
#        "F": "Foxtrot",
#        "G": "Golf",
#        "H": "Hotel",
#        "I": "India",
#        "J": "Juliet",
#        "K": "Kilo",
#        "L": "Lima",
#        "M": "Mike",
#        "N": "November",
#        "O": "Oscar",
#        "P": "Papa",
#        "Q": "Quebec",
#        "R": "Romeo",
#        "S": "Sierra",
#        "T": "Tango",
#        "U": "Uniform",
#        "V": "Victor",
#        "W": "Whiskey",
#        "X": "Xray",
#        "Y": "Yankee",
#        "Z": "Zulu"
#    }
# Напишите программу, которая будет запрашивать слово у пользователя и отображать его на экране в виде шифра из соответствующих слов, обозначающих буквы исходного текста. Например, если пользователь введет слово Hello, на экране должна быть отображена следующая последовательность слов: Hotel Echo Lima Lima Oscar. Для решения этой задачи вам предстоит использовать рекурсивную функцию, а не циклы. При этом все небуквенные символы, введенные пользователем должны отображаться как есть.

##########################################################

# 4.15.task.py
# Рекурсия. Сумма всех нечётных чисел.
# Вывести на экран сумму всех нечётных чисел в списке.
# Список: data = [1, 2, 3, 4, 5, 6, 7, 8, 9]

##########################################################

# 4.16.task.py
# Рекурсия. Сумма нечётных чисел и вычитание чётных чисел.
# Вывести на экран сумму всех нечётных чисел в списке минус сумму всех чётных.
# Список: data = [1, 2, 3, 4, 5, 6, 7, 8, 9]

##########################################################

# 4.17.task.py
# Рекурсия. Цифры в строке.
# Пользователь вводит произвольный текст. Программа с помощью рекурсии должна вывести из введённой строки только цифры.

##########################################################

# 4.18.task.py
# Рекурсия. Стратегия "разделяй и властвуй". Квадратные участки земли.
# НУЖНО РАВНОМЕРНО РАЗДЕЛИТЬ УЧАСТОК ЗЕМЛИ НА ОДИНАКОВЫЕ КВАДРАТНЫЕ УЧАСТКИ. УЧАСТКИ ДОЛЖНЫ БЫТЬ НАСТОЛЬКО БОЛЬШИМИ, НАСКОЛЬКО ЭТО ВОЗМОЖНО. НЕ ДОЛЖНО ОСТАТЬСЯ НЕИСПОЛЬЗОВАННОГО МЕСТА НА УЧАСТКЕ.

##########################################################

# 4.19.task.py
# Рекурсия. Количество элементов в списке.
# Нужно реализовать рекурсивный алгоритм для подсчёта количества элементов в списке.

##########################################################

# 4.20.task.py
# Рекурсия. Стратегия "разделяй и властвуй". Бинарный поиск.
# Нужно реализовать рекурсивный алгоритм для реализации бинарного поиска.

##########################################################

# 4.21.task.py
# Рекурсия. АЛГОРИТМ БЫСТРОЙ СОРТИРОВКИ.
# РАБОТАЕТ НАМНОГО БЫСТРЕЕ СОРТИРОВКИ ВЫБОРОМ. ОСНОВАНА НА СТРАТЕГИИ ---РАЗДЕЛЯЙ И ВЛАСТВУЙ---.
# С помощью этого алгоритма необходимо отсортировать список [2, 1, 3, 4, 5].

##########################################################

# 4.22.task.py
# Графы. Поиск в ширину.
# Дан словарь (хеш-таблица): a = {"Девочка": ["Вася", "Петя"], "Вася": ["Семён", "Татьяна"], "Петя": ["Снежана"], "Семён": [], "Татьяна": ["Галя"], "Снежана": ["Катя", "Женя"], "Галя": ["Игорь"], "Катя": ["Человек-паук"], "Женя": ["Джон"], "Игорь": ["Железный человек"], "Железный человек": ["Человек-паук"]}.
# Допустим, что источник - это "Девочка". Ключ словаря носит имя какого-то человека, а значения ключа - это его знакомые. Нужно найти минимальный путь от "Девочки" к "Железному человеку" с помощью графов.

##########################################################

# 4.23.task.py
# Рекурсия. Стек.
# Нужно отобразить стек. Разберем список и соберём его заново, отображая в каждом шаге текущий элемент списка.

##########################################################

# 4.24.task.py
# Графы. Алгоритм Дейкстры.
# Реализовать граф с помощью алгоритма Дейкстры. Смотреть условие задачи: https://python.rubtsovdmitry.ru/content/4_algorithms/graphs_2_dijkstra's_algorithm.html

##########################################################

# 4.25.task.py
# Графы. Алгоритм Дейкстры. Задача №2.
# Реализовать граф с помощью алгоритма Дейкстры. Смотреть условие задачи: https://python.rubtsovdmitry.ru/content/4_algorithms/graphs_3_dijkstra's_algorithm.html

##########################################################

# 4.26.task.py
# Жадные алгоритмы. Задача составления расписания.
# Смотреть условие программы с иллюстрациями: https://python.rubtsovdmitry.ru/content/4_algorithms/greed_1_schedule.html

##########################################################

# 4.27.task.py
# Жадные алгоритмы. Задача о рюкзаке (пример того, когда алгоритм не даёт наилучшего решения).
# Смотреть условие программы с иллюстрациями: https://python.rubtsovdmitry.ru/content/4_algorithms/greed_2_backpack.html

##########################################################

# 4.28.task.py
# Жадные алгоритмы. Задача о покрытии множества.
# Смотреть условие программы с иллюстрациями: https://python.rubtsovdmitry.ru/content/4_algorithms/greed_3_covering_set.html

##########################################################

# 4.29.task.py
# Жадные алгоритмы. Задача о коммивояжере.
# Смотреть условие программы с иллюстрациями: https://python.rubtsovdmitry.ru/content/4_algorithms/greed_4_traveling_salesman.html

##########################################################

# 4.30.task.py
# Рекурсия. Алгоритм Евклида. Найти наибольший общий делитель.
# Нужно найти наибольший общий делитель для двух чисел.

##########################################################

# 4.31.task.py
# Сортировка пузырьком.
# Нужно написать программу, которая сортирует список методом "Cортировки пузырьком".
# Смотреть условие программы с иллюстрациями: https://python.rubtsovdmitry.ru/content/4_algorithms/bubble_sorting.html

##########################################################

# 4.32.task.py
# Сортировка вставками.
# Нужно написать программу, которая сортирует список методом "Cортировки вставками".
# Смотреть условие программы с иллюстрациями: https://python.rubtsovdmitry.ru/content/4_algorithms/insertion_sort.html

##########################################################

# 4.33.task.py
# Сортировка слиянием.
# Нужно написать программу, которая сортирует список алгоритмом "сортировки слиянием".
# Смотреть условие программы с иллюстрациями: https://python.rubtsovdmitry.ru/content/4_algorithms/recursion_21_merge_sorting.html

##########################################################

# 4.34.task.py
# Класс "Стек".
# Нужно написать Нужно написать класс "Стек".
# В классе должны быть следующие методы:
# - добавить элемент в очередь;
# - убрать последний элемент;
# - посмотреть вершину стека;
# - проверить пуст ли стек;
# - узнать размер стека;
# - вывести стек на экран.
# Смотреть условие программы с иллюстрациями: https://python.rubtsovdmitry.ru/content/4_algorithms/class_stack.html

##########################################################

# 4.35.task.py
# Класс "Очередь-FIFO".
# Нужно написать класс "Очередь-FIFO".
# В классе должны быть следующие методы:
# - добавить элемент в очередь;
# - убрать первый элемент;
# - посмотреть последний элемент в очереди;
# - посмотреть первый элемент в очереди;
# - проверить пуста ли очередь;
# - узнать размер очереди;
# - очистить очередь;
# - вывести очередь на экран.
# Смотреть условие программы с иллюстрациями: https://python.rubtsovdmitry.ru/content/4_algorithms/class_fifo.html

##########################################################

# 4.36.task.py
# Класс "Очередь-FIFO" (продолжение, программа "Танцоры").
# Будет два варианта программы:
# 1) Во входных данных простой список: data = [("Василий", "м"), ("Виталий", "м"), ("Виктор", "м"), ("Пётр", "м"), ("Евгений", "м"), ("Николай", "м"), ("Ирина", "ж"), ("Екатерина", "ж"), ("Евгения", "ж"), ("Анастасия", "ж")];
# 2) Во втором варианте сложный список: data = [("Василий", "м", 3), ("Виталий", "м", 8), ("Виктор", "м", 7), ("Пётр", "м", 8), ("Евгений", "м", 5), ("Николай", "м", 9), ("Ирина", "ж", 5), ("Екатерина", "ж", 9), ("Евгения", "ж", 9), ("Анастасия", "ж", 4)]
# Используя абстрактную структуру данных, такую как "Очередь-FIFO", описанную ранее, нужно в первом случае отобрать мальчиков и девочек по парам для участия в конкурсе танцев. А во втором случае нужно отобрать участников ещё и по их оценкам. Мальчики или девочки, которым не хватило партнёров, в конкурсе участвовать не будут.
# Смотреть условие программы с иллюстрациями: https://python.rubtsovdmitry.ru/content/4_algorithms/class_fifo_dancing.html

##########################################################

# 4.37.task.py
# Необходимо обработать HTML-файл (4.37.class_stack_tags.html), который можно найти в репозитории GitHub в текущем разделе или на странице: https://python.rubtsovdmitry.ru/content/4_algorithms/class_stack_tag.html   
# Нужно выяснить совпадает ли количество открывающих тегов "head" с количеством закрывающих "/head".
# А также проверить теги "title" и "/title".
# Для этого необходимо воспользоваться классом "Стек" из предыдущей программы.
